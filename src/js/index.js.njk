---
permalink: /js/index.js
---
    var isMobile = false
function addMobileClass() {
  if (/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
    document.body.classList.add('mobile');
    $('body').addClass('turnOn');
    isMobile = true
  } else {
    document.body.classList.remove('mobile');
  }
}

// Run immediately
addMobileClass();

// Optional: run again if window is resized (for responsive desktops)
window.addEventListener('resize', addMobileClass);

    var tick_init = true
function easeInOutSine(x){
return x === 0 ? 0 : Math.pow(2, 10 * x - 10);
}

(function () {
  // update all matching elements by class
  function setTextAll(cls, text) {
    const els = document.getElementsByClassName(cls);
    for (let i = 0; i < els.length; i++) els[i].textContent = text;
  }

  const V2 = 'https://solarprotocol.net/api/v2/opendata.php';
  const V1 = 'https://solarprotocol.net/api/v1/opendata.php';

  // robust systemInfo fetcher: tries v2 JSON then v1 text; accepts {key:..} or {value:..}
  async function sys(key) {
    const urls = [`${V2}?systemInfo=${encodeURIComponent(key)}`, `${V1}?systemInfo=${encodeURIComponent(key)}`];
    for (const u of urls) {
      try {
        const r = await fetch(u, { cache: 'no-store' });
        if (!r.ok) continue;
        if (u.includes('/v2/')) {
          const j = await r.json();
          const val = (j && (j[key] ?? j.value)) ?? '';
          if (String(val).trim() !== '') return String(val).trim();
        } else {
          const t = (await r.text()).replace(/["\n\r]/g, '').trim();
          if (t) return t;
        }
      } catch (_) {}
    }
    return '';
  }

  // robust value fetcher (e.g., battery-percentage)
  async function val(key) {
    const urls = [`${V2}?value=${encodeURIComponent(key)}`, `${V1}?value=${encodeURIComponent(key)}`];
    for (const u of urls) {
      try {
        const r = await fetch(u, { cache: 'no-store' });
        if (!r.ok) continue;
        const j = await r.json();
        const v = j[key] ?? j.value ?? null;
        if (v != null) return v;
      } catch (_) {}
    }
    return null;
  }

  let tz = ''; // timezone string for Intl

  async function boot() {
    // 1) metadata
    const [name, location, city, country, bat] = await Promise.all([
      sys('name'), sys('location'), sys('city'), sys('country'), val('battery-percentage')
    ]);

    const locText = (location && location.trim()) || (city && country ? `${city}, ${country}` : '');

    setTextAll('sp-name', name || '‚Äî');
    setTextAll('sp-loc',  locText || '‚Äî');
    if (bat != null) setTextAll('sp-bat', `${bat}%`);

    // 2) timezone ‚Üí start clock + animations
    tz = await sys('tz') || 'UTC';
    tick();
    setInterval(tick, 1000);

    // 3) refresh server + tz every 5 min (active server can change)
    setInterval(async () => {
      try {
        const [n2, l2, c2, co2] = await Promise.all([sys('name'), sys('location'), sys('city'), sys('country')]);
        const loc2 = (l2 && l2.trim()) || (c2 && co2 ? `${c2}, ${co2}` : '');
        setTextAll('sp-name', n2 || '‚Äî');
        setTextAll('sp-loc',  loc2 || '‚Äî');
        const tz2 = await sys('tz');
        if (tz2) tz = tz2;
      } catch (e) {
        console.warn('[SP] refresh failed', e);
      }
    }, 5 * 60 * 1000);

    // quick inspect
    window.SP_DEBUG = { name, location: locText, battery: bat, tz };
    console.debug('[SP]', window.SP_DEBUG);
  }

  function tick() {
    if (!tz) return;

    const parts = new Intl.DateTimeFormat(undefined, {
      timeZone: tz, hour: '2-digit', minute: '2-digit', second: '2-digit', hourCycle: 'h23'
    }).formatToParts(new Date());

    let h = 0, m = 0, s = 0;
    for (const p of parts) {
      if (p.type === 'hour')   h = parseInt(p.value, 10);
      if (p.type === 'minute') m = parseInt(p.value, 10);
      if (p.type === 'second') s = parseInt(p.value, 10);
    }

    setTextAll('sp-time', `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`);

    const secs  = h * 3600 + m * 60 + s;
    const angle = map(secs, 0, 86400, 0, 360) - 90;

    const sun      = document.getElementsByClassName('ovalDiv_sun')[0];
    const moon     = document.getElementsByClassName('ovalDiv_moon')[0];
    const sun_img  = document.getElementsByClassName('ovalDiv_sun_img')[0];
    const moon_img = document.getElementsByClassName('ovalDiv_moon_img')[0];

    // your gradient bar logic intact
    if (secs > 21600 && secs < 64800) {
      var sel = Math.round(map(angle, 0, 180, 20/2, (11-2)*20 - 20/2))+20;
      if((sel>180 || sel<40)){
        sel = sel +20
      }else if((sel>140 || sel<80)){
        sel = sel +8
      }
      for (var i = sel; i >= 1; i--) {
        let sml =  ((easeInOutSine((sel - i) / sel)) / 2) * 100/8;
        let big = (100 - ((easeInOutSine((sel - i) / sel)) / 2) * 100)/8;
        $('.bar_' + (sel - i)).css({ 'background': `linear-gradient(0deg, transparent ${50 - sml - 5}%, black ${50 - sml}%, black ${50 + sml}%, transparent ${50 + sml + 5}%)` });
      }
      for (var j = 1; j >= 0; j--) {
        let sml2 = ((easeInOutSine((j) / 20)) / 2) * 100/8/2;
        let big2 =( 100 - ((easeInOutSine((j) / 20)) / 2) * 100)/8/2;
        $('.bar_' + (sel + sel -  j)).css({ 'background': `linear-gradient(0deg, transparent ${50 - sml2 - 5}%, black ${50 - sml2}%, black ${50 + sml2}%, transparent ${50 + sml2 + 5}%)` });
      }
    }
    if (typeof tick_init !== 'undefined' && tick_init) {
      if ((angle+3600)%360 < 180) $('.ovalDiv_sun').addClass('shadow'); else $('.ovalDiv_moon').addClass('shadow');
      console.log(angle)
      setTimeout(() => { $('body').addClass('turnOn'); }, 1000);
      tick_init = false;
    }

    if (sun)      animate(angle, sun);
    if (moon)     animate(angle - 180, moon);
    if (sun_img)  animate(angle, sun_img);
    if (moon_img) animate(angle - 180, moon_img);

  }

  document.addEventListener('DOMContentLoaded', boot);
})();

function map(value, start1, stop1, start2, stop2) {
  return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
}

    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight * 0.25;
    const radiusX = window.innerHeight * 0.5; // horizontal radius (ellipse width)
    const radiusY = window.innerHeight * 0.5; // vertical radius (ellipse height)
    const degToRad = (deg) => (deg) * Math.PI / 180;
$('#ovalRoute').css({'width':radiusX*2 +'px'})
$('#ovalRoute').css({'height':radiusY*2 +'px'})
$('#ovalRoute').css({'left':centerX +'px'})
$('#ovalRoute').css({'top':centerY +'px'})
    function animate(angle,elem) {
        const x = centerX + radiusX * Math.cos(degToRad(angle));
        const y = centerY + radiusY * Math.sin(degToRad(angle));
        elem.style.left = x + "px";
        elem.style.top = y + "px";
    }
$(document).ready(function() {
  let inactivityTimer;

  function startInactivityTimer() {
    inactivityTimer = setTimeout(function() {
        if(!isMobile){
              $('body').removeClass('turnOn');
          }
    }, 30000); // 1 minute = 60000ms
  }

  function resetTimer() {
    clearTimeout(inactivityTimer);
    $('body').addClass('turnOn');
    startInactivityTimer();
  }

  $(document).on('mousemove', resetTimer);

  // Start the initial timer when page loads
  startInactivityTimer();
});





    $(document).ready(function(){


        $(function(){
  var h = $(".side").outerHeight();
  // center horizontally, use half the height for vertical center
  $(".sidebottom .background_image").css("background-position", "center " + "calc(50% - " + (h) + "px)");
  
  // optional: recalc on resize
  $(window).on("resize", function(){
    var h =  $(".side").outerHeight();
    $(".sidebottom .background_image").css("background-position", "center " + "calc(50% - " + (h) + "px)");
  });
});




for (var i = 1; i <= 14; i++) {
    $('.side').append('<div class="background_image_wrap background_image_wrap_'+i+'"><div class="background_image background_image_'+i+'"></div></div>')
}
for (var i = 1; i <= 14; i++) {
    $('.sidebottom').find('.perspective_wrap').append('<div class="background_image_wrap background_image_wrap_'+i+'"><div class="background_image background_image_'+i+'"></div></div>')
}
        
        var scroll_counter = 0

            scroll(scroll_counter)
            scroll_img(scroll_counter)
$('.sidetop').append('\
    <div class="artistname_wrap">\
        {% for artwork in artworks %}<div class="artistname artistname_{{ loop.index }}" >{{ artwork.artist }}</div>\
        {% endfor %}\
    </div>\
    ')
$('.barhide').hover(function(){
    $('.bar').css({'opacity':0})
},function(){
    $('.bar').css({'opacity':1})
})
$('.sidetop').hover(function(){
    $('.sidetop').removeClass('sidetop_hovered')
    $(this).addClass('sidetop_hovered')
    var selected = parseInt($(this).attr('class').split('side_')[1].split(' ')[0])
    scroll_img(6-selected+scroll_counter)
    // $(this)
},function(){
    $(this).removeClass('sidetop_hovered')
    $('.sidetop.side_6').addClass('sidetop_hovered')
    scroll_img(scroll_counter)
})

{% for artwork in artworks %}
$('.side_{{ loop.index }} .background_image_wrap').click(function() { window.location.href  = 'detail/{{ artwork.slug }}.html'; });
{% endfor %}

{% for artwork in artworks %}
$('.artistname_{{ loop.index }}').click(function() { window.location.href =  'detail/{{ artwork.slug }}.html'; });
{% endfor %}

        $('.artistname_3').click(function(){
            $('.popup_3').show()
        })
        $('.close').click(function(){
            $(this).parent().hide()
        })




// Reuse your bounds
const MIN_COUNTER = -8;
const MAX_COUNTER = 5;

// Single source of truth
function applyScroll(counter) {
  // clamp
  if (counter < MIN_COUNTER) counter = MIN_COUNTER;
  if (counter > MAX_COUNTER) counter = MAX_COUNTER;

  // call your existing functions
  scroll(counter);
  scroll_img(counter);
  // scroll_sun();

  return counter;
}

// Hook arrow clicks to shared logic
$('.arrow_r').on('click', function(){
  scroll_counter--;
  scroll_counter = applyScroll(scroll_counter);
});
$('.arrow_l').on('click', function(){
  scroll_counter++;
  scroll_counter = applyScroll(scroll_counter);
});

// ---- Swipe support (mobile-friendly) ----
(function attachSwipe(areaSelector){
  const $area = $(areaSelector);               // change selector if you want a narrower zone
  const SWIPE_PX = 40;                          // horizontal distance threshold
  const SWIPE_MS = 600;                         // max duration to count as a swipe

  let startX = 0, startY = 0, startT = 0, activeId = null;

  // Use pointer events so it works on touch + pen + mouse
  $area.on('pointerdown', function(e){
    // Only react to primary touches
    if (e.pointerType === 'mouse' && e.buttons !== 1) return;
    activeId = e.pointerId;
    startX = e.clientX;
    startY = e.clientY;
    startT = performance.now();
  });

  $area.on('pointerup pointercancel', function(e){
    if (e.pointerId !== activeId) return;
    activeId = null;

    const dt = performance.now() - startT;
    if (dt > SWIPE_MS) return;                 // too slow; ignore

    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    // Must be mostly horizontal and pass threshold
    if (Math.abs(dx) < SWIPE_PX || Math.abs(dx) <= Math.abs(dy)) return;

    if (dx < 0) {
      // swipe LEFT -> same as right arrow click (move forward)
      scroll_counter--;
    } else {
      // swipe RIGHT -> same as left arrow click (move backward)
      scroll_counter++;
    }
    scroll_counter = applyScroll(scroll_counter);
  });

})('body'); 




        function scroll(selected){
            $('.artistname_wrap').css({'transform':'translateX('+(7.1428*selected)+'%)'})
            // $('.sidebottom .background_image_wrap').css({'transform':'translateX('+(7.1428*(scroll_counter-1))+'%) translateY('+(100*(scroll_counter+1))+'%)'})
        }
        function scroll_img(selected){
            $('.background_image_wrap').css({'transform':'translateX('+(7.1428*(selected-5))+'%) translateY('+(100*(selected-5))+'%)'})
        }
    })







const sideElements = document.querySelectorAll('.background_image_wrap');
let sunlightStrength = 0;
var lat = 0
var lon = 0
// üîÑ Fetch sunlight info using user's current location
async function fetchSunlightFromLocation() {
  try {
    navigator.geolocation.getCurrentPosition(async (position) => {
      lat = position.coords.latitude;
      lon = position.coords.longitude;

      const today = new Date().toISOString().split("T")[0];

      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=shortwave_radiation_sum,sunshine_duration&timezone=auto&start_date=${today}&end_date=${today}`;

      const res = await fetch(url);
      const data = await res.json();
      const watts = data.daily.shortwave_radiation_sum[0]; // MJ/m¬≤
      sunlightStrength = watts;

    });
  } catch (err) {
    console.error("Failed to get location or solar data", err);
  }
}
async function fetch4DayHourlyArchive(lat, lon) {
  const now = new Date();
  const endDate = now.toISOString().split("T")[0];

  const start = new Date();
  start.setDate(now.getDate() - 4); // get extra buffer in case of gaps
  const startDate = start.toISOString().split("T")[0];

  const url = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${startDate}&end_date=${endDate}&hourly=shortwave_radiation&timezone=auto`;

  try {
    const res = await fetch(url);
    const data = await res.json();

    const time = data.hourly.time;
    const radiation = data.hourly.shortwave_radiation;

    // Combine time and value, filter out nulls
    const combined = time
      .map((t, i) => ({ time: t, value: radiation[i] }))
      .filter(entry => entry.value != null);

    // Slice the latest 72 entries (last 72 hours)
    const last72 = combined.slice(-80);

    console.log("‚òÄÔ∏è Last 72 Hours of Radiation (clean):", last72);
    return last72;
  } catch (e) {
    console.error("‚ùå Failed to fetch solar archive", e);
    return [];
  }
}

// üîÅ Add a bar every 5 seconds using sunlight strength
function addSunlightBar() {
  const height = sunlightStrength * 5; // Scale factor
  const bar = document.createElement("div");
  bar.className = "bar";
  bar.style.height = `${height}px`;

  sideElements.forEach((side) => {
    side.appendChild(bar.cloneNode(true));
  });
}

    for (var i = 11; i >= 1; i--) {
        for (var k = 20; k >= 0; k--) {
            const bar = document.createElement("div");
            bar.className = "bar bar_"+(k+((11-i)*20));
            // var bigval =Math.max(parent_height-(value * scalefactor),value * scalefactor)
            // var smlval = Math.min(parent_height-(value * scalefactor),value * scalefactor)
            // if(value>0){
            // bar.style.background = `
            // linear-gradient(0deg, black ${smlval}px, transparent ${smlval}px, 
            //                             transparent ${bigval}px, black ${bigval}px)`;
            //                         }else{
            // bar.style.background = `black`;
            //                         }
            
            // bar.title = `${solarData[i].time} ‚Üí ${value} W/m¬≤`;
            $('.side_'+i+' .bar_wrap').append(bar)
        }
    }


// *****Cannot get accurate solarData
// navigator.geolocation.getCurrentPosition(async (pos) => {
//   const lat = pos.coords.latitude;
//   const lon = pos.coords.longitude;

//   const solarData = await fetch4DayHourlyArchive(lat, lon);


// if (solarData && solarData.length >= 44) {
//     const values = solarData.map(entry => entry.value);
//     const maxValue = Math.max(...values);
//     const scalefactor = $('.background_image_wrap').outerHeight() / maxValue

//         var parent_height = $('.background_image_wrap').outerHeight()
//         console.log(parent_height)
//   // Loop through all 72 radiation values
//   for (let i = 44; i >= 0; i--) {
//     const value = solarData[i].value;
//         for (var k = 20; k >= 0; k--) {

//             const bar = document.createElement("div");
//             bar.className = "bar";
//             var bigval =Math.max(parent_height-(value * scalefactor),value * scalefactor)
//             var smlval = Math.min(parent_height-(value * scalefactor),value * scalefactor)
//             if(value>0){
//             bar.style.background = `
//             linear-gradient(0deg, black ${smlval}px, transparent ${smlval}px, 
//                                         transparent ${bigval}px, black ${bigval}px)`;
//                                     }else{
//             bar.style.background = `black`;
//                                     }
            
//             bar.title = `${solarData[i].time} ‚Üí ${value} W/m¬≤`;
//             $('.background_image_wrap').append(bar)
//         }
//   }
// }


//   solarData.forEach(entry => {
//     console.log(`${entry.time} ‚Üí ${entry.value} W/m¬≤`);
//   });
// });

// // üîÅ Start fetching every 60s
// fetchSunlightFromLocation();
// setInterval(fetchSunlightFromLocation, 60*60 * 1000);

// // üîÅ Add new bars every 5s
// setInterval(addSunlightBar, 5000);


